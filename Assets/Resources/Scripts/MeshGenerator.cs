using System.Collections;
using System.Collections.Generic;
using UnityEngine;
//@Author Krystian Sarowski
public class MeshGenerator : MonoBehaviour
{
    //The map grid recreated as a 2D array of squares.
    public SquareGrid m_squareGrid;

    //The mesh filter for the walls.
    [SerializeField]
    MeshFilter m_walls;

    [SerializeField]
    MeshFilter m_outerMesh;

    //List of the vartices created from the squares within the square grid.
    List<Vector3> m_vertices;

    //List of vertiex ids, every three ids a triangle is created.
    List<int> m_triangles;

    //A dictionary of trirangles used to identify the number of triangles that share the same vertex.
    Dictionary<int, List<Triangle>> m_triangleDictionary = new Dictionary<int, List<Triangle>>();

    //List of all the wall outlines within the generated map grid.
    //For now there will be only one list as all room are connected.
    List<List<int>> m_wallOutlines = new List<List<int>>();

    //A hash set of visited vertices to speed up the creation of the walls.
    HashSet<int> m_checkedVertices = new HashSet<int>();

    public void GenerateMesh(TileGrid t_tileGrid, float t_squareSize, float t_wallHeight, TileType t_tileType)
    {
        m_triangleDictionary.Clear();
        m_wallOutlines.Clear();
        m_checkedVertices.Clear();

        m_squareGrid = new SquareGrid(t_tileGrid, t_squareSize, t_tileType);

        m_vertices = new List<Vector3>();
        m_triangles = new List<int>();

        for (int x = 0; x < m_squareGrid.m_squares.GetLength(0); x++)
        {
            for (int y = 0; y < m_squareGrid.m_squares.GetLength(1); y++)
            {
                TriangulateSquare(m_squareGrid.m_squares[x, y]);
            }
        }

        Mesh mesh = new Mesh();
        m_outerMesh.mesh = mesh;

        mesh.vertices = m_vertices.ToArray();
        mesh.triangles = m_triangles.ToArray();
        mesh.RecalculateNormals();

        Vector2[] uvs = new Vector2[m_vertices.Count];
        for (int i = 0; i < m_vertices.Count; i++)
        {
            float percentX = Mathf.InverseLerp(0, t_tileGrid.m_width * t_squareSize, m_vertices[i].x);
            float percentY = Mathf.InverseLerp(0, t_tileGrid.m_height * t_squareSize, m_vertices[i].z);
            uvs[i] = new Vector2(percentX, percentY);
        }
        mesh.uv = uvs;

        CreateWallMesh(t_wallHeight);
    }

    void CreateWallMesh(float t_wallHeight)
    {
        CalculateMeshOutlines();
        
        //The positions of the wall vertices copied from the varices used to
        //generate the shape of the floor outline.
        List<Vector3> wallVertices = new List<Vector3>();

        //The list of the IDs for the triangles used to create the wall mesh.
        List<int> wallTriangles = new List<int>();

        //The mesh for the walls generated by this function.
        Mesh wallMesh = new Mesh();

        List<Vector2> uvs = new List<Vector2>();

        foreach (List<int> outline in m_wallOutlines)
        {
            for (int i = 0; i < outline.Count - 1; i++)
            {
                int startIndex = wallVertices.Count;
                wallVertices.Add(m_vertices[outline[i]]);                           //Top Left Corner
                wallVertices.Add(m_vertices[outline[i + 1]]);                       //Top Right Corner
                wallVertices.Add(m_vertices[outline[i]] - Vector3.up * t_wallHeight); //Bottom Left Corner
                wallVertices.Add(m_vertices[outline[i + 1]] - Vector3.up * t_wallHeight); //Bottom Right Corner

                uvs.Add(new Vector2(0, 1));
                uvs.Add(new Vector2(1, 1));
                uvs.Add(new Vector2(0, 0));
                uvs.Add(new Vector2(1, 0));

                wallTriangles.Add(startIndex + 0);
                wallTriangles.Add(startIndex + 2);
                wallTriangles.Add(startIndex + 3);

                wallTriangles.Add(startIndex + 3);
                wallTriangles.Add(startIndex + 1);
                wallTriangles.Add(startIndex + 0);
            }
        }

        wallMesh.vertices = wallVertices.ToArray();
        wallMesh.triangles = wallTriangles.ToArray();
        wallMesh.RecalculateNormals();
        wallMesh.uv = uvs.ToArray();

        m_walls.mesh = wallMesh;

        MeshCollider wallsCollider = m_walls.gameObject.AddComponent<MeshCollider>();
        wallsCollider.sharedMesh = m_walls.mesh;
        m_walls.tag = "Walls";
    }

    void TriangulateSquare(Square square)
    {
        switch (square.m_configuration)
        {
            case 0:
                break;

            //1 corner is active.
            case 1:
                MeshFromPoints(square.m_centreLeft, square.m_centre, square.m_centreBottom, square.m_bottomLeft);
                break;
            case 2:
                MeshFromPoints(square.m_bottomRight, square.m_centreBottom, square.m_centre, square.m_centreRight);
                break;
            case 4:
                MeshFromPoints(square.m_topRight, square.m_centreRight, square.m_centre, square.m_centreTop);
                break;
            case 8:
                MeshFromPoints(square.m_topLeft, square.m_centreTop, square.m_centre, square.m_centreLeft);
                break;

            //2 corner are active.
            case 3:
                MeshFromPoints(square.m_centreRight, square.m_bottomRight, square.m_bottomLeft, square.m_centreLeft);
                break;
            case 6:
                MeshFromPoints(square.m_centreTop, square.m_topRight, square.m_bottomRight, square.m_centreBottom);
                break;
            case 9:
                MeshFromPoints(square.m_topLeft, square.m_centreTop, square.m_centreBottom, square.m_bottomLeft);
                break;
            case 12:
                MeshFromPoints(square.m_topLeft, square.m_topRight, square.m_centreRight, square.m_centreLeft);
                break;
            case 5:
                MeshFromPoints(square.m_centreTop, square.m_topRight, square.m_centreRight, square.m_centreBottom, square.m_bottomLeft, square.m_centreLeft);
                break;
            case 10:
                MeshFromPoints(square.m_topLeft, square.m_centreTop, square.m_centreRight, square.m_bottomRight, square.m_centreBottom, square.m_centreLeft);
                break;

            //3 corners are active this is a unique case for which the triangles need to be done in special way.
            case 7:
                MeshFromPoints(square.m_centreLeft, square.m_centre, square.m_centreBottom, square.m_bottomLeft);
                MeshFromPoints(square.m_bottomRight, square.m_centreBottom, square.m_centre, square.m_centreRight);
                MeshFromPoints(square.m_topRight, square.m_centreRight, square.m_centre, square.m_centreTop);
                break;
            case 11:
                MeshFromPoints(square.m_centreLeft, square.m_centre, square.m_centreBottom, square.m_bottomLeft);
                MeshFromPoints(square.m_bottomRight, square.m_centreBottom, square.m_centre, square.m_centreRight);
                MeshFromPoints(square.m_topLeft, square.m_centreTop, square.m_centre, square.m_centreLeft);
                break;
            case 13:
                MeshFromPoints(square.m_centreLeft, square.m_centre, square.m_centreBottom, square.m_bottomLeft);
                MeshFromPoints(square.m_topRight, square.m_centreRight, square.m_centre, square.m_centreTop);
                MeshFromPoints(square.m_topLeft, square.m_centreTop, square.m_centre, square.m_centreLeft);
                break;
            case 14:
                MeshFromPoints(square.m_bottomRight, square.m_centreBottom, square.m_centre, square.m_centreRight);
                MeshFromPoints(square.m_topRight, square.m_centreRight, square.m_centre, square.m_centreTop);
                MeshFromPoints(square.m_topLeft, square.m_centreTop, square.m_centre, square.m_centreLeft);
                break;

            //4 corners are active.
            case 15:
                MeshFromPoints(square.m_topLeft, square.m_topRight, square.m_bottomRight, square.m_bottomLeft);
                m_checkedVertices.Add(square.m_topLeft.m_id);
                m_checkedVertices.Add(square.m_topRight.m_id);
                m_checkedVertices.Add(square.m_bottomRight.m_id);
                m_checkedVertices.Add(square.m_bottomLeft.m_id);
                break;
        }
    }

    /// <summary>
    /// Winds up the passed in points into triangles in a clockwise manor.
    /// The number of triangles created is based of the number of points passed in.
    /// </summary>
    /// <param name="t_vertices">An array of vertices from which the trinagles will be formed</param>
    void MeshFromPoints(params Vertex[] t_vertices)
    {
        AssignVertexIDs(t_vertices);

        if (t_vertices.Length >= 3)
        {
            CreateTriangle(t_vertices[0], t_vertices[1], t_vertices[2]);
        }

        if (t_vertices.Length >= 4)
        {
            CreateTriangle(t_vertices[0], t_vertices[2], t_vertices[3]);
        }

        if (t_vertices.Length >= 5)
        {
            CreateTriangle(t_vertices[0], t_vertices[3], t_vertices[4]);
        }

        if (t_vertices.Length >= 6)
        {
            CreateTriangle(t_vertices[0], t_vertices[4], t_vertices[5]);
        }
    }

    /// <summary>
    /// Assigns vertex ids to the passed in vertices if the vertex does not already
    /// have an id. The value of the id assigned will be equal to the current size
    /// of the vertices array.
    /// </summary>
    /// <param name="t_vertices">List of vertices to which ids will be assigned</param>
    void AssignVertexIDs(params Vertex[] t_vertices)
    {
        for (int i = 0; i < t_vertices.Length; i++)
        {
            if (t_vertices[i].m_id == -1)
            {
                t_vertices[i].m_id = m_vertices.Count;
                m_vertices.Add(t_vertices[i].m_position);
            }
        }
    }

    /// <summary>
    /// Creates a triangle from the passed in vertices.
    /// </summary>
    /// <param name="t_vertexA">The first vertex of the triangle</param>
    /// <param name="t_vertexB">The second vertex of the trinagle</param>
    /// <param name="t_vertexC">The third vertex of the trinagle</param>
    void CreateTriangle(Vertex t_vertexA, Vertex t_vertexB, Vertex t_vertexC)
    {
        m_triangles.Add(t_vertexA.m_id);
        m_triangles.Add(t_vertexB.m_id);
        m_triangles.Add(t_vertexC.m_id);

        Triangle triangle = new Triangle(t_vertexA.m_id, t_vertexB.m_id, t_vertexC.m_id);

        AddTriangleToDictionary(triangle[0], triangle);
        AddTriangleToDictionary(triangle[1], triangle);
        AddTriangleToDictionary(triangle[2], triangle);
    }

    /// <summary>
    /// Adds the triangle to the dictionery of trinagles which store 
    /// a list of traingles for each vertex ID that share that vertex.
    /// </summary>
    /// <param name="t_vertexKeyID">The id of the vertex</param>
    /// <param name="t_triangle">The triangle that contains that vertex</param>
    void AddTriangleToDictionary(int t_vertexKeyID, Triangle t_triangle)
    {
        if (m_triangleDictionary.ContainsKey(t_vertexKeyID))
        {
            m_triangleDictionary[t_vertexKeyID].Add(t_triangle);
        }
        else
        {
            List<Triangle> triangleList = new List<Triangle>();
            triangleList.Add(t_triangle);
            m_triangleDictionary.Add(t_vertexKeyID, triangleList);
        }
    }

    void CalculateMeshOutlines()
    {
        for (int vertID = 0; vertID < m_vertices.Count; vertID++)
        {
            if (!m_checkedVertices.Contains(vertID))
            {
                int newOutlineVertex = GetConnectedOutlineVertex(vertID);
                if (newOutlineVertex != -1)
                {
                    m_checkedVertices.Add(vertID);

                    List<int> newOutline = new List<int>();
                    newOutline.Add(vertID);
                    m_wallOutlines.Add(newOutline);
                    TraceOutlineEdge(newOutlineVertex, m_wallOutlines.Count - 1);
                    m_wallOutlines[m_wallOutlines.Count - 1].Add(vertID);
                }
            }
        }
    }

    void TraceOutlineEdge(int t_vertexID, int t_outlineID)
    {
        m_wallOutlines[t_outlineID].Add(t_vertexID);
        m_checkedVertices.Add(t_vertexID);
        int nextVertexIndex = GetConnectedOutlineVertex(t_vertexID);

        if (nextVertexIndex != -1)
        {
            TraceOutlineEdge(nextVertexIndex, t_outlineID);
        }
    }

    int GetConnectedOutlineVertex(int t_vertexID)
    {
        List<Triangle> trianglesContainingVertex = m_triangleDictionary[t_vertexID];

        for (int i = 0; i < trianglesContainingVertex.Count; i++)
        {
            Triangle triangle = trianglesContainingVertex[i];

            for (int j = 0; j < 3; j++)
            {
                int connectedVetexID = triangle[j];

                if (connectedVetexID != t_vertexID && !m_checkedVertices.Contains(connectedVetexID))
                {
                    if (IsOutlineEdge(t_vertexID, connectedVetexID))
                    {
                        return connectedVetexID;
                    }
                }
            }
        }

        return -1;
    }

    bool IsOutlineEdge(int t_vertexOne, int t_vertexTwo)
    {
        List<Triangle> trianglesWithVetexOne = m_triangleDictionary[t_vertexOne];
        int sharedCount = 0;

        for (int i = 0; i < trianglesWithVetexOne.Count && sharedCount <= 1; i++)
        {
            if (trianglesWithVetexOne[i].Contains(t_vertexTwo))
            {
                sharedCount++;
            }
        }

        return sharedCount == 1;
    }

    struct Triangle
    {
        //List of vertex ids for the three corners within the triangle.
        List<int> m_vertIDs;

        public Triangle(int t_idA, int t_idB, int t_idC)
        {
            m_vertIDs = new List<int>();
            m_vertIDs.Add(t_idA);
            m_vertIDs.Add(t_idB);
            m_vertIDs.Add(t_idC);
        }

        /// <summary>
        /// Simplified method of accessing the vertex id's 
        /// within the trinagle.
        /// </summary>
        /// <param name="i">The index for the vertex ID within the list</param>
        /// <returns>Vertex ID for the passed index within the triangle</returns>
        public int this[int i]
        {
            get
            {
                return m_vertIDs[i];
            }
        }

        public bool Contains(int t_vertexID)
        {
            return m_vertIDs.Contains(t_vertexID); 
        }
    }

    public class SquareGrid
    {
        public Square[,] m_squares;

        public SquareGrid(TileGrid t_tileGrid, float t_squareSize, TileType t_tileType)
        {
            int mapWidth = t_tileGrid.m_width;
            int mapHight = t_tileGrid.m_height;

            PrimaryVertex[,] primaryVertexGrid = new PrimaryVertex[mapWidth, mapHight];

            for (int x = 0; x < mapWidth; x++)
            {
                for (int y = 0; y < mapHight; y++)
                {
                    Vector3 position = new Vector3(x * t_squareSize + t_squareSize / 2, 0, y * t_squareSize + t_squareSize / 2);
                    primaryVertexGrid[x, y] = new PrimaryVertex(position, t_tileGrid.GetTile(new GridIndex(x, y)).GetTileType() == t_tileType, t_squareSize);

                }
            }

            m_squares = new Square[mapWidth - 1, mapHight - 1];

            for (int x = 0; x < mapWidth - 1; x++)
            {
                for (int y = 0; y < mapHight - 1; y++)
                {
                    m_squares[x, y] = new Square(primaryVertexGrid[x, y + 1], primaryVertexGrid[x + 1, y + 1], primaryVertexGrid[x + 1, y], primaryVertexGrid[x, y]);
                }
            }
        }
    }

    public class Square
    {
        //The four corners within the square as vetexes.
        public PrimaryVertex m_topLeft, m_topRight, m_bottomLeft, m_bottomRight;

        //Mid points on the edges of the square between each of the corners.
        public Vertex m_centreLeft, m_centreTop, m_centreRight, m_centreBottom;

        //The centre of the square as a vertex.
        public Vertex m_centre;

        //A unique value used to determine quickly the combination of active 
        //corners within a square. 
        public int m_configuration;

        public Square(PrimaryVertex t_topLeft, PrimaryVertex t_topRight, PrimaryVertex t_bottomRight, PrimaryVertex t_bottomLeft)
        {
            m_topLeft = t_topLeft;
            m_topRight = t_topRight;
            m_bottomRight = t_bottomRight;
            m_bottomLeft = t_bottomLeft;

            m_centreTop = m_topLeft.m_right;
            m_centreRight = m_bottomRight.m_top;
            m_centreBottom = m_bottomLeft.m_right;
            m_centreLeft = m_bottomLeft.m_top;
            m_centre = m_bottomLeft.m_topRight;

            if (m_topLeft.m_isActive)
            {
                m_configuration += 8;
            }
                
            if (m_topRight.m_isActive)
            {
                m_configuration += 4;
            }
                
            if (m_bottomRight.m_isActive)
            {
                m_configuration += 2;
            }
                
            if (m_bottomLeft.m_isActive)
            {
                m_configuration += 1;
            }
        }
    }

    public class Vertex
    {
        //The position of the vertex within the world space.
        public Vector3 m_position;

        //ID of the vertex used to make it unique within the array of
        //points that is used to create the triangles.
        public int m_id = -1;

        public Vertex(Vector3 t_position)
        {
            m_position = t_position;
        }
    }

    public class PrimaryVertex : Vertex
    {
        //Bool for if the vertex is active or not. If it is not then
        //it is not a wall.
        public bool m_isActive;

        //Each of these vertexes are at a mid way point to the next primary vertex.
        //Each primary vertex handles the mid way points for the to the right and up from it.
        public Vertex m_top, m_right, m_topRight;

        public PrimaryVertex(Vector3 t_pos, bool t_isActive, float t_distToNextPrimary) : 
            base(t_pos)
        {
            m_isActive = t_isActive;

            Vector3 vertexPos = m_position + Vector3.forward * t_distToNextPrimary / 2.0f;
            m_top = new Vertex(vertexPos);

            vertexPos = m_position + Vector3.right * t_distToNextPrimary / 2.0f;
            m_right = new Vertex(vertexPos);

            vertexPos = m_position + Vector3.right * t_distToNextPrimary / 2.0f + Vector3.forward * t_distToNextPrimary / 2.0f;
            m_topRight = new Vertex(vertexPos);
        }
    }
}